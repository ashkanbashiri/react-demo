{"ast":null,"code":"export function getMergeSortAnimations(array){var animations=[];if(array.length<=1)return array;var auxiliaryArray=array.slice();mergeSortHelper(array,0,array.length-1,auxiliaryArray,animations);return[animations,array];}function mergeSortHelper(mainArray,startIdx,endIdx,auxiliaryArray,animations){if(startIdx===endIdx)return;var middleIdx=Math.floor((startIdx+endIdx)/2);mergeSortHelper(auxiliaryArray,startIdx,middleIdx,mainArray,animations);mergeSortHelper(auxiliaryArray,middleIdx+1,endIdx,mainArray,animations);doMerge(mainArray,startIdx,middleIdx,endIdx,auxiliaryArray,animations);}function doMerge(mainArray,startIdx,middleIdx,endIdx,auxiliaryArray,animations){var k=startIdx;var i=startIdx;var j=middleIdx+1;while(i<=middleIdx&&j<=endIdx){// These are the values that we're comparing; we push them once\n// to change their color.\nanimations.push([i,j]);// These are the values that we're comparing; we push them a second\n// time to revert their color.\nanimations.push([i,j]);if(auxiliaryArray[i]<=auxiliaryArray[j]){// We overwrite the value at index k in the original array with the\n// value at index i in the auxiliary array.\nanimations.push([k,auxiliaryArray[i]]);mainArray[k++]=auxiliaryArray[i++];}else{// We overwrite the value at index k in the original array with the\n// value at index j in the auxiliary array.\nanimations.push([k,auxiliaryArray[j]]);mainArray[k++]=auxiliaryArray[j++];}}while(i<=middleIdx){// These are the values that we're comparing; we push them once\n// to change their color.\nanimations.push([i,i]);// These are the values that we're comparing; we push them a second\n// time to revert their color.\nanimations.push([i,i]);// We overwrite the value at index k in the original array with the\n// value at index i in the auxiliary array.\nanimations.push([k,auxiliaryArray[i]]);mainArray[k++]=auxiliaryArray[i++];}while(j<=endIdx){// These are the values that we're comparing; we push them once\n// to change their color.\nanimations.push([j,j]);// These are the values that we're comparing; we push them a second\n// time to revert their color.\nanimations.push([j,j]);// We overwrite the value at index k in the original array with the\n// value at index j in the auxiliary array.\nanimations.push([k,auxiliaryArray[j]]);mainArray[k++]=auxiliaryArray[j++];}}export function getquickSortAnimations(array){var animations=[];quickSortHelper(array,0,array.length-1,animations);return[animations,array];}function partition(arr,low,high,animations){var pivot=arr[high];var i=low-1;// index of smaller element\nfor(var j=low;j<high;j++){// If current element is smaller than the pivot\nanimations.push([j,high]);animations.push([j,high]);if(arr[j]<pivot){i++;// swap arr[i] and arr[j]\nanimations.push([i,arr[j]]);animations.push([j,arr[i]]);var _temp=arr[i];arr[i]=arr[j];arr[j]=_temp;}else{animations.push([i+1,arr[i]]);animations.push([j,arr[j]]);}}// swap arr[i+1] and arr[high] (or pivot)\nanimations.push([i+1,high]);animations.push([i+1,high]);animations.push([i+1,arr[high]]);animations.push([high,arr[i+1]]);var temp=arr[i+1];arr[i+1]=arr[high];arr[high]=temp;return i+1;}/* The main function that implements QuickSort() \r\n      arr[] --> Array to be sorted, \r\n      low  --> Starting index, \r\n      high  --> Ending index */function quickSortHelper(arr,low,high,animations){if(low<high){/* pi is partitioning index, arr[pi] is  \r\n              now at right place */var pi=partition(arr,low,high,animations);// Recursively sort elements before\n// partition and after partition\nquickSortHelper(arr,low,pi-1,animations);quickSortHelper(arr,pi+1,high,animations);}}export function getBubbleSortAnimations(array){var animations=[];var n=array.length;for(var i=0;i<n-1;i++){for(var j=0;j<n-i-1;j++){animations.push([j,j+1]);animations.push([j,j+1]);if(array[j]>array[j+1]){// swap arr[j+1] and arr[i]\nanimations.push([j,array[j+1]]);animations.push([j+1,array[j]]);var temp=array[j];array[j]=array[j+1];array[j+1]=temp;}else{animations.push([j,array[j]]);animations.push([j+1,array[j+1]]);}}}return[animations,array];}","map":{"version":3,"sources":["C:/Users/Univ of Virginia/Documents/GitHub/sorting-visualizer/src/sortingAlgorithms/sortingAlgorithms.js"],"names":["getMergeSortAnimations","array","animations","length","auxiliaryArray","slice","mergeSortHelper","mainArray","startIdx","endIdx","middleIdx","Math","floor","doMerge","k","i","j","push","getquickSortAnimations","quickSortHelper","partition","arr","low","high","pivot","temp","pi","getBubbleSortAnimations","n"],"mappings":"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","sourcesContent":["export function getMergeSortAnimations(array) {\r\n  const animations = [];\r\n  if (array.length <= 1) return array;\r\n  const auxiliaryArray = array.slice();\r\n  mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\r\n  return [animations, array];\r\n}\r\n\r\nfunction mergeSortHelper(\r\n  mainArray,\r\n  startIdx,\r\n  endIdx,\r\n  auxiliaryArray,\r\n  animations,\r\n) {\r\n  if (startIdx === endIdx) return;\r\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\r\n  mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\r\n  mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\r\n  doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\r\n}\r\n\r\nfunction doMerge(\r\n  mainArray,\r\n  startIdx,\r\n  middleIdx,\r\n  endIdx,\r\n  auxiliaryArray,\r\n  animations,\r\n) {\r\n  let k = startIdx;\r\n  let i = startIdx;\r\n  let j = middleIdx + 1;\r\n  while (i <= middleIdx && j <= endIdx) {\r\n    // These are the values that we're comparing; we push them once\r\n    // to change their color.\r\n    animations.push([i, j]);\r\n    // These are the values that we're comparing; we push them a second\r\n    // time to revert their color.\r\n    animations.push([i, j]);\r\n    if (auxiliaryArray[i] <= auxiliaryArray[j]) {\r\n      // We overwrite the value at index k in the original array with the\r\n      // value at index i in the auxiliary array.\r\n      animations.push([k, auxiliaryArray[i]]);\r\n      mainArray[k++] = auxiliaryArray[i++];\r\n    } else {\r\n      // We overwrite the value at index k in the original array with the\r\n      // value at index j in the auxiliary array.\r\n      animations.push([k, auxiliaryArray[j]]);\r\n      mainArray[k++] = auxiliaryArray[j++];\r\n    }\r\n  }\r\n  while (i <= middleIdx) {\r\n    // These are the values that we're comparing; we push them once\r\n    // to change their color.\r\n    animations.push([i, i]);\r\n    // These are the values that we're comparing; we push them a second\r\n    // time to revert their color.\r\n    animations.push([i, i]);\r\n    // We overwrite the value at index k in the original array with the\r\n    // value at index i in the auxiliary array.\r\n    animations.push([k, auxiliaryArray[i]]);\r\n    mainArray[k++] = auxiliaryArray[i++];\r\n  }\r\n  while (j <= endIdx) {\r\n    // These are the values that we're comparing; we push them once\r\n    // to change their color.\r\n    animations.push([j, j]);\r\n    // These are the values that we're comparing; we push them a second\r\n    // time to revert their color.\r\n    animations.push([j, j]);\r\n    // We overwrite the value at index k in the original array with the\r\n    // value at index j in the auxiliary array.\r\n    animations.push([k, auxiliaryArray[j]]);\r\n    mainArray[k++] = auxiliaryArray[j++];\r\n  }\r\n}\r\n\r\nexport function getquickSortAnimations(array) {\r\n  const animations = [];\r\n  quickSortHelper(array, 0, array.length - 1, animations);\r\n  return [animations, array];\r\n}\r\n\r\nfunction partition(arr, low, high, animations) {\r\n  const pivot = arr[high];\r\n  let i = low - 1; // index of smaller element\r\n  for (let j = low; j < high; j++) {\r\n    // If current element is smaller than the pivot\r\n    animations.push([j, high]);\r\n    animations.push([j, high]);\r\n    if (arr[j] < pivot) {\r\n      i++;\r\n      // swap arr[i] and arr[j]\r\n      animations.push([i, arr[j]]);\r\n      animations.push([j, arr[i]]);\r\n      let temp = arr[i];\r\n      arr[i] = arr[j];\r\n      arr[j] = temp;\r\n    } else {\r\n      animations.push([i + 1, arr[i]]);\r\n      animations.push([j, arr[j]]);\r\n    }\r\n  }\r\n\r\n  // swap arr[i+1] and arr[high] (or pivot)\r\n  animations.push([i + 1, high]);\r\n  animations.push([i + 1, high]);\r\n  animations.push([i + 1, arr[high]]);\r\n  animations.push([high, arr[i + 1]]);\r\n  let temp = arr[i + 1];\r\n  arr[i + 1] = arr[high];\r\n  arr[high] = temp;\r\n\r\n  return i + 1;\r\n}\r\n\r\n/* The main function that implements QuickSort() \r\n      arr[] --> Array to be sorted, \r\n      low  --> Starting index, \r\n      high  --> Ending index */\r\nfunction quickSortHelper(arr, low, high, animations) {\r\n  if (low < high) {\r\n    /* pi is partitioning index, arr[pi] is  \r\n              now at right place */\r\n    let pi = partition(arr, low, high, animations);\r\n\r\n    // Recursively sort elements before\r\n    // partition and after partition\r\n    quickSortHelper(arr, low, pi - 1, animations);\r\n    quickSortHelper(arr, pi + 1, high, animations);\r\n  }\r\n}\r\n\r\nexport function getBubbleSortAnimations(array) {\r\n  const animations = [];\r\n  const n = array.length;\r\n  for (let i = 0; i < n - 1; i++) {\r\n    for (let j = 0; j < n - i - 1; j++) {\r\n      animations.push([j, j + 1]);\r\n      animations.push([j, j + 1]);\r\n      if (array[j] > array[j + 1]) {\r\n        // swap arr[j+1] and arr[i]\r\n        animations.push([j, array[j + 1]]);\r\n        animations.push([j + 1, array[j]]);\r\n        let temp = array[j];\r\n        array[j] = array[j + 1];\r\n        array[j + 1] = temp;\r\n      } else {\r\n        animations.push([j, array[j]]);\r\n        animations.push([j + 1, array[j + 1]]);\r\n      }\r\n    }\r\n  }\r\n  return [animations, array];\r\n}\r\n"]},"metadata":{},"sourceType":"module"}